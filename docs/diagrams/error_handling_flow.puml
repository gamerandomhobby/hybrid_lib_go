@startuml error_handling_flow
!theme plain

title Error Handling Flow (LIBRARY)\nRailway-Oriented Programming with Result[T] Monad

actor "Consumer\nApp Code" as User

participant "API\napi/desktop.Greeter" as API #FFEBCD
participant "Application\nusecase.GreetUseCase" as Application #E8F5E9
participant "Infrastructure\nadapter.ConsoleWriter" as Infrastructure #E6F3FF
participant "Domain\nerror.Result[T]" as Domain #FFF9E6

== Happy Path (Success) ==

User -> API : greeter.Execute(ctx, api.NewGreetCommand("Alice"))
activate API

API -> API : Delegate to UseCase
note right
  ```go
  // API/desktop wires infrastructure
  return g.useCase.Execute(ctx, cmd)
  ```
end note

API -> Application : useCase.Execute(ctx, cmd)\n[STATIC DISPATCH]
activate Application

Application -> Application : valueobject.CreatePerson(name)
note right
  Domain validation
  Returns Result[Person]
end note

Application -> Infrastructure : writer.Write(ctx, "Hello, Alice!")\n[STATIC DISPATCH]
activate Infrastructure

Infrastructure -> Infrastructure : fmt.Fprintln(w, message)
note right
  **Panic Recovery Pattern**
  defer/recover catches panics
  Transforms to Result
end note

Infrastructure --> Application : domerr.Ok(model.UnitValue)
deactivate Infrastructure

Application --> API : domerr.Ok(model.UnitValue)
deactivate Application

API --> User : api.Ok(api.Unit{})
deactivate API

note right of User
  ```go
  if result.IsOk() {
    // Greeting was written
  }
  ```
end note

== Error Path (Infrastructure Failure) ==

User -> API : greeter.Execute(ctx, api.NewGreetCommand("Bob"))
activate API

API -> Application : useCase.Execute(ctx, cmd)
activate Application

Application -> Infrastructure : writer.Write(ctx, "Hello, Bob!")
activate Infrastructure

Infrastructure -> Infrastructure : fmt.Fprintln fails\nor panics
note right #FFCCCC
  **Exception Boundary**
  defer/recover catches panic
  I/O errors mapped to Result
end note

Infrastructure -> Domain : domerr.Err[model.Unit](\n  apperr.NewInfrastructureError(\n    "write failed: ..."))
activate Domain

Domain --> Infrastructure : Error(InfrastructureError)
deactivate Domain

Infrastructure --> Application : Error(InfrastructureError)
deactivate Infrastructure

Application --> API : Error(InfrastructureError)
deactivate Application

API --> User : api.Err(InfrastructureError)
deactivate API

note right of User
  ```go
  if result.IsError() {
    errInfo := result.ErrorInfo()
    // errInfo.Kind == api.InfrastructureError
    // errInfo.Message == "write failed: ..."
  }
  ```
end note

== Error Path (Domain Validation) ==

User -> API : greeter.Execute(ctx, api.NewGreetCommand(""))
activate API

API -> Application : useCase.Execute(ctx, cmd)
activate Application

Application -> Domain : valueobject.CreatePerson("")
activate Domain

Domain -> Domain : Validate name\n(length > 0)
note right #FFCCCC
  **Domain Validation**
  Pure function check
  No exceptions
  Returns Error variant
end note

Domain --> Application : Error(ValidationError)
deactivate Domain

Application --> API : Error(ValidationError)
deactivate Application

API --> User : api.Err(ValidationError)
deactivate API

note right of User
  ```go
  switch result.ErrorInfo().Kind {
  case api.ValidationError:
    // Handle validation error
  case api.InfrastructureError:
    // Handle infra error
  }
  ```
end note

== Context Cancellation Path ==

User -> API : greeter.Execute(ctx, cmd)\n(ctx is cancelled)
activate API

API -> Application : useCase.Execute(ctx, cmd)
activate Application

Application -> Infrastructure : writer.Write(ctx, message)
activate Infrastructure

Infrastructure -> Infrastructure : select {\ncase <-ctx.Done():\n  return Err\n}
note right #FFCCCC
  **Context Cancellation**
  Checked before I/O
  Returns InfrastructureError
end note

Infrastructure --> Application : Error(InfrastructureError:\n"write cancelled: context canceled")
deactivate Infrastructure

Application --> API : Error(InfrastructureError)
deactivate Application

API --> User : api.Err(InfrastructureError)
deactivate API

legend right
  **Library Error Handling**
  ════════════════════════════════════
  1. **Consumer**: Calls API, handles Result
  2. **API/desktop**: Wires infrastructure,
     delegates to UseCase
  3. **Application**: Orchestrates, propagates errors
  4. **Infrastructure**: Catches panics via
     defer/recover, checks context
  5. **Domain**: Validates, returns Error variant

  **Key Patterns**
  ════════════════════════════════════
  • Result[T] monad (not Go error interface)
  • Panic recovery at infrastructure boundary
  • Context cancellation support
  • Railway-oriented programming
  • Consumer pattern matches on ErrorKind

  **Static Dispatch**
  ════════════════════════════════════
  • All method calls resolved at compile time
  • Zero runtime overhead (no interface vtable)
  • Type safety verified by compiler
endlegend

@enduml
