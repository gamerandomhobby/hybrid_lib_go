@startuml application_error_pattern
!theme plain

title Application Error Re-export Pattern\nPreventing Transitive Domain Access

package "Domain Layer" as Domain #FFF9E6 {
  class "domain/error" as DomainError {
    + ErrorType : struct
    + ErrorKind : type
    + ValidationError : const
    + InfrastructureError : const
    + Result[T] : generic struct
    --
    Canonical error definitions
  }
}

package "Application Layer" as Application #E8F5E9 {
  class "application/error" as AppError {
    + ErrorType : type alias
    + ErrorKind : type alias
    + Result[T] : type alias
    + ValidationError : var alias
    + InfrastructureError : var alias
    --
    **Re-exports domain/error**
    Zero overhead (type aliases)
  }

  class "application/port/outbound" as Writer {
    + WriterPort : interface
    + Write(ctx, message) : Result[Unit]
    --
    **Static dispatch via generics**
    Returns domain/error.Result
  }
}

package "Presentation Layer" as Presentation #FFE4E1 {
  class "presentation/adapter/cli/command" as GreetCmd {
    + Run() : int
    --
    Uses **application/error**
    NOT domain/error
  }
}

package "Infrastructure Layer" as Infrastructure #E6F3FF {
  class "infrastructure/adapter" as ConsoleWriter {
    + ConsoleWriter : struct
    + Write(ctx, message) : Result[Unit]
    + NewWriter(io.Writer) : *ConsoleWriter
    --
    Implements **WriterPort**
    Uses **domain/error** directly
    (allowed for Infrastructure)
  }
}

' Relationships
DomainError <.. AppError : re-exports\n(type aliases)
AppError <.. Writer : uses
AppError <.. GreetCmd : uses ✅
DomainError <.. ConsoleWriter : uses ✅

' Forbidden
GreetCmd .right.> DomainError #red : ❌ FORBIDDEN\nMust use application/error

note right of AppError
  **Re-export Pattern**
  ═══════════════════════════

  ```go
  import (
    domerr "domain/error"
  )

  // Type aliases - zero overhead
  type ErrorType = domerr.ErrorType
  type ErrorKind = domerr.ErrorKind
  type Result[T any] = domerr.Result[T]

  // Variable re-exports
  var (
    ValidationError = domerr.ValidationError
    InfrastructureError = domerr.InfrastructureError
  )
  ```
end note

note bottom of GreetCmd
  **Presentation Usage**
  ═══════════════════════

  ```go
  import (
    apperr "application/error"
  )
  // NOT: import domerr "domain/error" ❌

  errInfo := result.ErrorInfo()

  switch errInfo.Kind {
  case apperr.ValidationError:
    fmt.Fprintln(os.Stderr, "Invalid input")
  case apperr.InfrastructureError:
    fmt.Fprintln(os.Stderr, "System error")
  }
  ```
end note

note bottom of ConsoleWriter
  **Infrastructure Usage**
  ════════════════════════

  ```go
  import (
    domerr "domain/error"  // ✅ Allowed
  )

  // Infrastructure CAN access
  // domain/error directly
  return domerr.Err[model.Unit](
    domerr.NewInfrastructureError(
      "I/O failed"))
  ```
end note

legend right
  **Pattern Benefits**
  ═══════════════════════════════
  ✅ Zero overhead (type aliases)
  ✅ Compile-time enforcement (go.mod)
  ✅ Clear boundary between layers
  ✅ Single source of truth (Domain)
  ✅ Presentation decoupled from Domain

  **Why This Matters**
  ═══════════════════════════════
  • Domain is shareable across apps
  • Application/Presentation are app-specific
  • Multiple UIs can use same Domain
  • Forces use case thinking
endlegend

@enduml
