@startuml package_structure
!theme plain
skinparam componentStyle rectangle

title Package Structure (LIBRARY)\nActual Packages in Each Layer

frame "API Layer (Public Facade)" #FFEBCD {
  component "api" as APIFacade
  component "api/desktop" as APIDesktop
  note right of APIFacade
    **Public Entry Point**
    Re-exports domain + application types

    ```go
    type Result[T any] = domerr.Result[T]
    type Person = valueobject.Person
    type GreetCommand = command.GreetCommand
    type WriterPort = outbound.WriterPort
    ```
  end note
  note right of APIDesktop
    **Platform Wiring**
    Creates ready-to-use greeter

    ```go
    func NewGreeter() *Greeter {
      writer := adapter.NewConsoleWriter()
      uc := usecase.NewGreetUseCase[
        *adapter.ConsoleWriter](writer)
      return &Greeter{useCase: uc}
    }
    ```
  end note
}

frame "Infrastructure Layer" #E6F3FF {
  component "infrastructure/adapter" as InfraConsole
  note right of InfraConsole
    **Depends on:**
    - application/port/outbound
    - domain/error (direct)
    - application/model

    **Implements WriterPort:**
    ConsoleWriter.Write(ctx, msg)
  end note
}

frame "Application Layer" #E8F5E9 {
  component "application/command" as AppCommand
  component "application/usecase" as AppUsecase
  component "application/port/outbound" as AppOutbound
  component "application/port/inbound" as AppInbound
  component "application/model" as AppModel
  component "application/error" as AppError

  note right of AppUsecase
    **Generic Use Case**
    Static dispatch via generics

    ```go
    type GreetUseCase[W WriterPort] struct {
      writer W
    }
    ```
  end note
}

frame "Domain Layer" #FFF9E6 {
  component "domain/error" as DomainError
  component "domain/error.Result[T]" as DomainResult
  component "domain/valueobject" as DomainPerson

  note right of DomainError
    **Zero external module deps**
    Pure domain logic
    Canonical error types
  end note
}

' API dependencies
APIFacade -down-> AppCommand : re-exports
APIFacade -down-> AppInbound : re-exports
APIFacade -down-> AppOutbound : re-exports
APIFacade -down-> DomainError : re-exports
APIFacade -down-> DomainPerson : re-exports

' API/desktop wires infrastructure
APIDesktop -down-> InfraConsole : wires
APIDesktop -down-> AppUsecase : creates
APIDesktop -left-> APIFacade : uses types

' Infrastructure dependencies
InfraConsole -down-> AppOutbound : implements WriterPort
InfraConsole -down-> DomainError : uses

' Application dependencies
AppCommand -down-> DomainPerson : uses
AppUsecase -down-> DomainPerson : validates
AppOutbound -down-> DomainResult : uses
AppInbound -down-> DomainResult : uses
AppError -down-> DomainError : re-exports

' Forbidden dependency (critical)
APIFacade .right.> InfraConsole #red : ❌ FORBIDDEN\nUse api/desktop

legend bottom
  **Library Package Structure**
  ════════════════════════════════════
  • api/         - Public facade (re-exports)
  • api/desktop/ - Platform-specific wiring
  • application/ - Use cases, ports, commands
  • domain/      - Pure business logic
  • infrastructure/ - Adapter implementations

  **Dependency Rules (LIBRARY)**
  ════════════════════════════════════
  ✅ api/ → application/* + domain/*
  ✅ api/desktop → ALL (composition root)
  ✅ Infrastructure → application/* + domain/*
  ✅ Application → domain/*
  ❌ api/ → infrastructure/* (use api/desktop)

  **Static Dispatch with Generics**
  ════════════════════════════════════
  • GreetUseCase[W WriterPort] - generic over writer
  • Concrete types known at compile time
  • Zero runtime overhead (no vtable)
endlegend

@enduml
