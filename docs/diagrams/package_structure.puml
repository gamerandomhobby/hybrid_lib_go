@startuml package_structure
!theme plain
skinparam componentStyle rectangle

title Package Structure\nActual Packages in Each Layer

frame "Bootstrap Layer" #FFEBCD {
  component "bootstrap/cli" as BootstrapCLI
  note right of BootstrapCLI
    **Composition Root**
    - Wires all dependencies
    - Generic instantiation
    - Application entry point

    ```go
    uc := usecase.NewGreetUseCase[
      *adapter.ConsoleWriter](writer)
    cmd := command.NewGreetCommand[
      *usecase.GreetUseCase[
        *adapter.ConsoleWriter]](uc)
    ```
  end note
}

frame "Presentation Layer" #FFE4E1 {
  component "presentation/adapter/cli/command" as PresentationGreet
  note right of PresentationGreet
    **Depends on:**
    - application/command
    - application/port/inbound
    - **application/error** ✅

    **Cannot access:**
    ❌ domain/* packages

    **Generic over GreetPort:**
    GreetCommand[UC GreetPort]
  end note
}

frame "Infrastructure Layer" #E6F3FF {
  component "infrastructure/adapter" as InfraConsole
  note right of InfraConsole
    **Depends on:**
    - application/port/outbound
    - domain/error (direct) ✅
    - application/model

    **Implements WriterPort:**
    ConsoleWriter.Write(ctx, msg)
  end note
}

frame "Application Layer" #E8F5E9 {
  component "application/error" as AppError #FFFF99
  component "application/command" as AppCommand
  component "application/usecase" as AppUsecase
  component "application/port/outbound" as AppOutbound
  component "application/port/inbound" as AppInbound
  component "application/model" as AppModel

  note right of AppError
    **Re-exports domain/error**
    For Presentation layer use

    ```go
    import domerr "domain/error"

    type ErrorType = domerr.ErrorType
    type ErrorKind = domerr.ErrorKind
    type Result[T any] = domerr.Result[T]

    var ValidationError = domerr.ValidationError
    ```
  end note
}

frame "Domain Layer" #FFF9E6 {
  component "domain/error" as DomainError
  component "domain/error.Result[T]" as DomainResult
  component "domain/valueobject" as DomainPerson

  note right of DomainError
    **Zero external module deps**
    Pure domain logic
    Canonical error types
  end note
}

' Dependencies (center-seeking - all point inward)
PresentationGreet -down-> AppCommand : uses DTO
PresentationGreet -down-> AppInbound : uses GreetPort
PresentationGreet -down-> AppError : uses ✅

InfraConsole -down-> AppOutbound : implements WriterPort
InfraConsole -down-> DomainError : uses ✅

AppCommand -down-> DomainPerson : uses
AppUsecase -down-> DomainPerson : validates
AppOutbound -down-> DomainResult : uses
AppInbound -down-> DomainResult : uses
AppError -down-> DomainError : re-exports

' Forbidden dependency (shown as violation)
PresentationGreet .right.> DomainError #red : ❌ FORBIDDEN\nNo transitive access

legend bottom
  **Package Naming Convention**
  ════════════════════════════════════
  All packages use hierarchical paths:
  • parent/child/grandchild pattern
  • Lowercase with underscores
  • Go module per layer

  **Example:**
  • Package: domain/valueobject
  • File: person.go
  • Type: Person

  **Dependency Rules**
  ════════════════════════════════════
  ✅ Presentation → application/* packages
  ✅ Infrastructure → application/* + domain/* packages
  ✅ Application → domain/* packages
  ❌ Presentation → domain/* packages (forbidden!)

  **Static Dispatch with Generics**
  ════════════════════════════════════
  • GreetUseCase[W WriterPort] - generic over writer
  • GreetCommand[UC GreetPort] - generic over use case
  • Concrete types known at compile time
  • Zero runtime overhead (no vtable)
endlegend

@enduml
